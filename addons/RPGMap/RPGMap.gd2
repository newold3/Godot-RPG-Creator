@tool
class_name RPGMapPlugin
extends EditorPlugin

enum MODE {NONE, EVENT, ENEMY_SPAWN, EVENT_REGION}

const RESIZE_HANDLE_SIZE = 8
const RESIZE_CURSORS = {
	"arrow": Control.CURSOR_ARROW,
	"top_left": Control.CURSOR_FDIAGSIZE,
	"top_right": Control.CURSOR_BDIAGSIZE,
	"bottom_left": Control.CURSOR_BDIAGSIZE,
	"bottom_right": Control.CURSOR_FDIAGSIZE,
	"left": Control.CURSOR_HSIZE,
	"right": Control.CURSOR_HSIZE,
	"top": Control.CURSOR_VSIZE,
	"bottom": Control.CURSOR_VSIZE,
	"move": Control.CURSOR_POINTING_HAND
}

const GRID_MOVEMENT_MODE = 1
const FREE_MOVEMENT_NODE = 2
const EVENT_MOVEMENT_MODE = 3

var is_resizing = false
var resize_handle = ""
var resize_start_pos = Vector2.ZERO
var resize_start_rect: Rect2
var current_cursor: Control.CursorShape = RESIZE_CURSORS.arrow


var event_button: Button
var enemy_spawn_region_button: Button
var event_region_button: Button
var event_container_control: MarginContainer
var enemy_spawn_container_control: MarginContainer
var event_region_container_control: MarginContainer
var event_container_control_window: Window
var enemy_spawn_container_control_window: Window
var event_region_container_control_window: Window
var current_object: RPGMap
var current_edit_mode: MODE = MODE.NONE
var current_tile_pos: Vector2i
var dragging_event: RPGEvent
var dragging_enemy_spawn_region: EnemySpawnRegion
var dragging_event_region: EventRegion
var moving_enemy_spawn_region: EnemySpawnRegion
var moving_event_region: EventRegion
var dragging_start_position: RPGMapPosition
var current_event: RPGEvent
var current_enemy_spawn_region: EnemySpawnRegion
var current_event_region: EventRegion
var drawing_region_start_position: Vector2
var current_region_position: Vector2i
var current_start_position: RPGMapPosition
var cursor: NinePatchRect
var selected_cursor: NinePatchRect

var scene_preview

var tile_popup_menu: PopupMenu
var region_popup_menu: PopupMenu
var start_position_popup_menu: PopupMenu

var clipboard: Dictionary = {}

var dialog_sizes: Dictionary

var busy: bool = false

var focus_tile_is_enabled: bool = true

const DETACHABLE_WINDOW = preload("res://addons/CustomControls/detachable_window.tscn")


func _enter_tree() -> void:
	tree_exiting.connect(_tree_exiting)
	
	#add_autoload_singleton("RPGMapsInfo", "res://addons/RPGMap/Scripts/maps_info.gd")
	#add_autoload_singleton("RPGSYSTEM", "res://addons/RPGMap/Scripts/system.gd")
	
	event_container_control = preload("res://addons/RPGMap/Scenes/event_container.tscn").instantiate()
	event_container_control.requested_edit_event.connect(_on_event_container_requested_edit)
	event_container_control.requested_remove_event.connect(_on_event_container_requested_remove)
	event_container_control.item_selected.connect(_on_event_container_item_selected)
	event_container_control.detach_panel.connect(_on_detach_event_container_control)
	
	event_button = add_control_to_bottom_panel(event_container_control, "Events")
	event_button.toggled.connect(_on_event_button_toggled)
	
	event_container_control.enable_plugin()

	enemy_spawn_container_control = preload("res://addons/RPGMap/Scenes/enemy_spawn_region_container.tscn").instantiate()
	enemy_spawn_container_control.requested_edit_region.connect(_on_enemy_spawn_region_container_requested_edit)
	enemy_spawn_container_control.requested_remove_region.connect(_on_enemy_spawn_region_container_requested_remove)
	enemy_spawn_container_control.item_selected.connect(_on_enemy_spawn_region_container_item_selected)
	enemy_spawn_container_control.detach_panel.connect(_on_detach_enemy_spawn_container_control)
	
	enemy_spawn_region_button = add_control_to_bottom_panel(enemy_spawn_container_control, "Enemy Spawn Regions")
	enemy_spawn_region_button.toggled.connect(_on_enemy_spawn_region_button_toggled)
	
	enemy_spawn_container_control.enable_plugin()
	
	event_region_container_control = preload("res://addons/RPGMap/Scenes/event_region_container.tscn").instantiate()
	event_region_container_control.requested_edit_region.connect(_on_region_event_container_requested_edit)
	event_region_container_control.requested_remove_region.connect(_on_region_event_container_requested_remove)
	event_region_container_control.item_selected.connect(_on_region_event_container_item_selected)
	event_region_container_control.detach_panel.connect(_on_detach_region_event_container_control)
	
	event_region_button = add_control_to_bottom_panel(event_region_container_control, "Region Events")
	event_region_button.toggled.connect(_on_event_region_button_toggled)
	
	event_region_container_control.enable_plugin()


	var selected_nodes = get_editor_interface().get_selection().get_selected_nodes()
	if selected_nodes.size() > 0:
		var buttons_visibility: bool = selected_nodes[0] is RPGMap and selected_nodes[0].can_add_events
		event_button.visible = buttons_visibility
		enemy_spawn_region_button.visible = buttons_visibility
		event_region_button.visible = buttons_visibility
	else:
		event_button.visible = false
		enemy_spawn_region_button.visible = false
		event_region_button.visible = false
	
	set_force_draw_over_forwarding_enabled()
	
	scene_preview = get_editor_interface().get_resource_previewer()
	
	
	var ins =  preload("res://addons/RPGMap/Scenes/rpg_tile_menu.tscn")
	tile_popup_menu = ins.instantiate()
	tile_popup_menu.visible = false
	tile_popup_menu.index_pressed.connect(_on_tile_popup_menu_index_pressed)
	tile_popup_menu.visibility_changed.connect(_on_tile_popup_menu_visibility_changed)
	call_deferred("add_child", tile_popup_menu)
	var sub_popup1 = tile_popup_menu.get_child(0)
	sub_popup1.index_pressed.connect(_on_tile_subpopup_menu1_index_pressed)
	var sub_popup2 = tile_popup_menu.get_child(1)
	sub_popup2.index_pressed.connect(_on_preset_pressed)
	tile_popup_menu.call_deferred("add_submenu_node_item", "Set start position for...", sub_popup1)
	tile_popup_menu.call_deferred("add_separator")
	tile_popup_menu.call_deferred("add_submenu_node_item", "Presets...", sub_popup2)
	tile_popup_menu.call_deferred("add_separator")
	
	ins =  preload("res://addons/RPGMap/Scenes/rpg_enemy_spawn_region_menu.tscn")
	region_popup_menu = ins.instantiate()
	region_popup_menu.visible = false
	region_popup_menu.index_pressed.connect(_on_region_popup_menu_index_pressed)
	region_popup_menu.visibility_changed.connect(_on_region_popup_menu_visibility_changed)
	call_deferred("add_child", region_popup_menu)
	
	ins =  preload("res://addons/RPGMap/Scenes/rpg_start_position_menu.tscn")
	start_position_popup_menu = ins.instantiate()
	start_position_popup_menu.visible = false
	start_position_popup_menu.index_pressed.connect(_on_start_position_popup_menu_index_pressed)
	call_deferred("add_child", start_position_popup_menu)
	
	add_custom_type("RPGMap", "TileMap", preload("res://addons/RPGData/ModulesRPG/rpg_map.gd"), null)
	
	get_tree().node_added.connect(_on_node_added)
	
	var nodes_selected = EditorInterface.get_selection().get_selected_nodes()
	if nodes_selected.size() > 0:
		EditorInterface.edit_node(nodes_selected[0])


func _tree_exiting() -> void:
	set_process(false)
	set_process_input(false)


func _exit_tree() -> void:
	#remove_autoload_singleton("RPGMapsInfo")
	#remove_autoload_singleton("RPGSYSTEM")
	get_tree().node_added.disconnect(_on_node_added)

	if event_container_control:
		if event_button:
			remove_control_from_bottom_panel(event_container_control)
		CustomTooltipManager.restore_all_tooltips_for(event_container_control)
		if FileCache.options.event_dialog.detached:
			event_container_control.get_parent().queue_free()
		else:
			event_container_control.queue_free()
	
	if enemy_spawn_container_control:
		if enemy_spawn_region_button:
			remove_control_from_bottom_panel(enemy_spawn_container_control)
		CustomTooltipManager.restore_all_tooltips_for(enemy_spawn_container_control)
		if FileCache.options.enemy_spawn_region_dialog.detached:
			enemy_spawn_container_control.get_parent().queue_free()
		else:
			enemy_spawn_container_control.queue_free()
	
	if current_object and current_object is RPGMap:
		current_object.editing_events = false
		current_object.editing_enemy_spawn_region = false
		current_object.queue_redraw()


func _on_detach_event_container_control(panel: MarginContainer) -> void:
	if event_container_control_window:
		event_container_control_window.show()
		event_container_control_window.grab_focus()
		return
		
	FileCache.options.event_dialog.detached = true
	var old_parent = panel.get_parent()
	panel.hide_detach_button(true)
	var w = DETACHABLE_WINDOW.instantiate()
	w.title = "Event List"
	if FileCache.options.event_dialog.position != Vector2i.ZERO:
		w.position = FileCache.options.event_dialog.position
	if FileCache.options.event_dialog.size != Vector2i.ZERO:
		w.size = FileCache.options.event_dialog.size
	get_parent().add_child(w)
	panel.get_parent().remove_child(panel)
	w.get_node("%MainContainer").add_child(panel)
	w.close_requested.connect(
		func():
			FileCache.options.event_dialog.detached = false
			FileCache.options.event_dialog.position = w.position
			FileCache.options.event_dialog.size = w.size
			panel.reparent(old_parent)
			old_parent.move_child(panel, 0)
			panel.hide_detach_button(false)
			w.queue_free()
			event_container_control_window = null
			CustomTooltipManager.replace_all_tooltips_with_custom(panel)
	)

	old_parent.size.y = 0
	event_container_control_window = w
	
	CustomTooltipManager.replace_all_tooltips_with_custom(panel)


func _on_detach_enemy_spawn_container_control(panel: MarginContainer) -> void:
	if enemy_spawn_container_control_window:
		enemy_spawn_container_control_window.show()
		enemy_spawn_container_control_window.grab_focus()
		return
		
	FileCache.options.enemy_spawn_region_dialog.detached = true
	var old_parent = panel.get_parent()
	panel.hide_detach_button(true)
	var w = DETACHABLE_WINDOW.instantiate()
	w.title = "Enemy Spawn Region List"
	if FileCache.options.enemy_spawn_region_dialog.position != Vector2i.ZERO:
		w.position = FileCache.options.enemy_spawn_region_dialog.position
	if FileCache.options.enemy_spawn_region_dialog.size != Vector2i.ZERO:
		w.size =FileCache.options.enemy_spawn_region_dialog.size
	get_parent().add_child(w)
	panel.get_parent().remove_child(panel)
	w.get_node("%MainContainer").add_child(panel)
	w.close_requested.connect(
		func():
			FileCache.options.enemy_spawn_region_dialog.detached = false
			FileCache.options.enemy_spawn_region_dialog.position = w.position
			FileCache.options.enemy_spawn_region_dialog.size = w.size
			panel.reparent(old_parent)
			old_parent.move_child(panel, 0)
			panel.hide_detach_button(false)
			w.queue_free()
			enemy_spawn_container_control_window = null
			CustomTooltipManager.replace_all_tooltips_with_custom(panel)
	)
	old_parent.size.y = 0
	enemy_spawn_container_control_window = w
	
	CustomTooltipManager.replace_all_tooltips_with_custom(panel)


func _on_detach_region_event_container_control(panel: MarginContainer) -> void:
	if event_region_container_control_window:
		event_region_container_control_window.show()
		event_region_container_control_window.grab_focus()
		return
		
	FileCache.options.event_region_dialog.detached = true
	var old_parent = panel.get_parent()
	panel.hide_detach_button(true)
	var w = DETACHABLE_WINDOW.instantiate()
	w.title = "Event Region List"
	if FileCache.options.event_region_dialog.position != Vector2i.ZERO:
		w.position = FileCache.options.event_region_dialog.position
	if FileCache.options.event_region_dialog.size != Vector2i.ZERO:
		w.size =FileCache.options.event_region_dialog.size
	get_parent().add_child(w)
	panel.get_parent().remove_child(panel)
	w.get_node("%MainContainer").add_child(panel)
	w.close_requested.connect(
		func():
			FileCache.options.event_region_dialog.detached = false
			FileCache.options.event_region_dialog.position = w.position
			FileCache.options.event_region_dialog.size = w.size
			panel.reparent(old_parent)
			old_parent.move_child(panel, 0)
			panel.hide_detach_button(false)
			w.queue_free()
			event_region_container_control_window = null
			CustomTooltipManager.replace_all_tooltips_with_custom(panel)
	)
	old_parent.size.y = 0
	event_region_container_control_window = w
	
	CustomTooltipManager.replace_all_tooltips_with_custom(panel)


func _on_event_container_requested_edit(index: int) -> void:
	if current_object:
		var event = current_object.events.get_event(index)
		if event:
			current_event = event
			current_tile_pos.x = event.x
			current_tile_pos.y = event.y
			show_edit_event_dialog()


func _on_enemy_spawn_region_container_requested_edit(index: int) -> void:
	if current_object:
		show_edit_region_dialog()


func _on_region_event_container_requested_edit(index: int) -> void:
	if current_object:
		show_edit_event_region_dialog()


func _on_event_container_requested_remove(index: int) -> void:
	if current_object:
		var event = current_object.events.get_event(index)
		if event:
			current_event = event
			current_tile_pos.x = event.x
			current_tile_pos.y = event.y
			remove_tile()


func _on_enemy_spawn_region_container_requested_remove(index: int) -> void:
	if current_object:
		var region = current_object.get_region(index)
		if region:
			current_enemy_spawn_region = region
			remove_region()


func _on_region_event_container_requested_remove(index: int) -> void:
	if current_object:
		var region = current_object.get_event_region(index)
		if region:
			current_event_region = region
			remove_event_region()


func _on_event_container_item_selected(index: int) -> void:
	if current_object:
		var event = current_object.events.get_event(index)
		if event:
			current_object.current_event = event
			current_object.refresh_canvas()
			if focus_tile_is_enabled:
				var pos: Vector2i = Vector2i(event.x, event.y) * current_object.tile_size
				_focus_any_item(pos, current_object.tile_size / 2)


func _on_enemy_spawn_region_container_item_selected(index: int) -> void:
	if current_object:
		var region = current_object.get_region(index)

		if region:
			current_object.region_selected = region
			current_object.refresh_canvas()
			if focus_tile_is_enabled:
				var pos: Vector2i = region.rect.position * current_object.tile_size
				_focus_any_item(pos, region.rect.size / 2)


func _on_region_event_container_item_selected(index: int) -> void:
	if current_object:
		var region = current_object.get_event_region(index)

		if region:
			current_object.event_region_selected = region
			current_object.refresh_canvas()
			if focus_tile_is_enabled:
				var pos: Vector2i = region.rect.position * current_object.tile_size
				_focus_any_item(pos, region.rect.size / 2)


func _focus_any_item(pos: Vector2, item_size: Vector2) -> void:
	if !current_object:
		return
	
	var editor = EditorInterface.get_base_control().find_child("@CanvasItemEditorViewport*", true, false)
	if !editor:
		return
	
	var editor_viewport_2d = EditorInterface.get_editor_viewport_2d()
	var s: Vector2 = editor_viewport_2d.get_final_transform().get_scale()
	var viewport_size: Vector2 = editor_viewport_2d.get_visible_rect().size
	
	var h_scroll = editor.find_child("@HScrollBar*", true, false)
	var v_scroll = editor.find_child("@VScrollBar*", true, false)
	if !h_scroll or !v_scroll:
		return
	
	# Calculate the centered position of the object
	var centered_pos = pos + item_size / 2
	
	# Check if the object is already visible on the screen
	var current_view_rect = Rect2(Vector2(h_scroll.value, v_scroll.value), viewport_size / s)
	if current_view_rect.has_point(centered_pos):
		return  # The object is already visible, we do nothing
	
	# Calculate the new offset position
	var new_scroll_pos = centered_pos - viewport_size / (2 * s)
	
	# Adjust scrollbar limits if necessary
	_adjust_scroll_limits(h_scroll, new_scroll_pos.x, viewport_size.x / s.x)
	_adjust_scroll_limits(v_scroll, new_scroll_pos.y, viewport_size.y / s.y)
	
	# Apply the displacement
	h_scroll.value = new_scroll_pos.x
	v_scroll.value = new_scroll_pos.y


func _adjust_scroll_limits(scroll_bar: ScrollBar, new_value: float, viewport_size: float) -> void:
	var half_viewport = viewport_size / 2
	
	# Adjust the minimum if necessary
	if new_value < scroll_bar.min_value + half_viewport:
		scroll_bar.min_value = new_value - half_viewport
	
	# Adjust the maximun if necessary
	if new_value > scroll_bar.max_value - half_viewport:
		scroll_bar.max_value = new_value + half_viewport
	
	# Make sure that the range is at least the size of the viewport.
	if scroll_bar.max_value - scroll_bar.min_value < viewport_size:
		scroll_bar.max_value = scroll_bar.min_value + viewport_size


func _on_node_added(node) -> void:
	if node is LineEdit or node is TextEdit:
		if !node.focus_entered.is_connected(_on_node_type1_focus_entered):
			node.focus_entered.connect(_on_node_type1_focus_entered.bind(node))


func _ready() -> void:
	get_tree().node_added.connect(_on_new_node_added)


func _process(delta: float) -> void:
	if current_edit_mode == MODE.EVENT and !event_button.is_pressed():
		_on_event_button_toggled(false)
	
	elif current_edit_mode == MODE.ENEMY_SPAWN and !enemy_spawn_region_button.is_pressed():
		_on_enemy_spawn_region_button_toggled(false)
	
	elif current_edit_mode == MODE.EVENT_REGION and !event_region_button.is_pressed():
		_on_event_region_button_toggled(false)
	
	if (not event_button.is_pressed() and
		not enemy_spawn_region_button.is_pressed() and
		not event_region_button.is_pressed() and
		current_object and
		"current_edit_button_pressed" in current_object
	):
		current_object.current_edit_button_pressed = -1


func _on_node_type1_focus_entered(node: Node) -> void:
	if !node.is_editable():
		node.release_focus()
		node.deselect()
		node.set_process_internal(false)
	else:
		node.set_process_internal(true)


func _on_new_node_added(node: Node) -> void:
	await get_tree().process_frame
	if !node or !is_instance_valid(node):
		return
	if node is RPGMap:
		if !node.tree_exited.is_connected(_on_rpgmap_exited):
			node.tree_exited.connect(_on_rpgmap_exited.bind(node))


func _on_rpgmap_exited(node: RPGMap) -> void:
	if current_object == node:
		current_object = null


func _on_event_button_toggled(toggled_on: bool) -> void:
	current_edit_mode = MODE.EVENT if toggled_on else MODE.NONE
	if current_object:
		current_object.set_editing_events(toggled_on)
	if toggled_on:
		EditorInterface.set_main_screen_editor("2D")
		if current_object:
			current_object.current_edit_button_pressed = 0
			get_editor_interface().get_selection().add_node(current_object)
			if "refresh_canvas" in current_object:
				current_object.refresh_canvas()
			if event_container_control:
				event_container_control.events = current_object.events
				event_container_control.refresh(true)
				if FileCache.options.event_dialog.detached:
					_on_detach_event_container_control(event_container_control)
					
		if enemy_spawn_container_control_window:
			FileCache.options.enemy_spawn_region_dialog.position = enemy_spawn_container_control_window.position
			FileCache.options.enemy_spawn_region_dialog.size = enemy_spawn_container_control_window.size
			enemy_spawn_container_control_window.hide()
		
		if event_region_container_control_window:
			FileCache.options.event_region_dialog.position = event_region_container_control_window.position
			FileCache.options.event_region_dialog.size = event_region_container_control_window.size
			event_region_container_control_window.hide()


func _on_enemy_spawn_region_button_toggled(toggled_on: bool) -> void:
	current_edit_mode = MODE.ENEMY_SPAWN if toggled_on else MODE.NONE
	if current_object:
		current_object.set_editing_enemy_spawn_regions(toggled_on)
	if toggled_on:
		EditorInterface.set_main_screen_editor("2D")
		if current_object:
			current_object.current_edit_button_pressed = 1
			get_editor_interface().get_selection().add_node(current_object)
			if "refresh_canvas" in current_object:
				current_object.refresh_canvas()
			if enemy_spawn_container_control:
				enemy_spawn_container_control.regions = current_object.regions
				enemy_spawn_container_control.refresh(true)
				if FileCache.options.enemy_spawn_region_dialog.detached:
					_on_detach_enemy_spawn_container_control(enemy_spawn_container_control)
					
		if event_container_control_window:
			FileCache.options.event_dialog.position = event_container_control_window.position
			FileCache.options.event_dialog.size = event_container_control_window.size
			event_container_control_window.hide()
		
		if event_region_container_control_window:
			FileCache.options.event_region_dialog.position = event_region_container_control_window.position
			FileCache.options.event_region_dialog.size = event_region_container_control_window.size
			event_region_container_control_window.hide()


func _on_event_region_button_toggled(toggled_on: bool) -> void:
	current_edit_mode = MODE.EVENT_REGION if toggled_on else MODE.NONE
	if current_object:
		current_object.set_editing_event_regions(toggled_on)
	if toggled_on:
		EditorInterface.set_main_screen_editor("2D")
		if current_object:
			current_object.current_edit_button_pressed = 2
			get_editor_interface().get_selection().add_node(current_object)
			if "refresh_canvas" in current_object:
				current_object.refresh_canvas()
			if event_region_container_control:
				event_region_container_control.regions = current_object.event_regions
				event_region_container_control.refresh(true)
				if FileCache.options.event_region_dialog.detached:
					_on_detach_enemy_spawn_container_control(event_region_container_control)
					
		if event_container_control_window:
			FileCache.options.event_dialog.position = event_container_control_window.position
			FileCache.options.event_dialog.size = event_container_control_window.size
			event_container_control_window.hide()
			
		if enemy_spawn_container_control_window:
			FileCache.options.enemy_spawn_region_dialog.position = enemy_spawn_container_control_window.position
			FileCache.options.enemy_spawn_region_dialog.size = enemy_spawn_container_control_window.size
			enemy_spawn_container_control_window.hide()


func _make_visible(visible: bool) -> void:
	pass


func _edit(object: Object) -> void:
	if event_container_control_window:
		FileCache.options.event_dialog.position = event_container_control_window.position
		FileCache.options.event_dialog.size = event_container_control_window.size
		event_container_control_window.hide()
	
	if enemy_spawn_container_control_window:
		FileCache.options.enemy_spawn_region_dialog.position = enemy_spawn_container_control_window.position
		FileCache.options.enemy_spawn_region_dialog.size = enemy_spawn_container_control_window.size
		enemy_spawn_container_control_window.hide()
	
	if event_region_container_control_window:
		FileCache.options.event_region_dialog.position = event_region_container_control_window.position
		FileCache.options.event_region_dialog.size = event_region_container_control_window.size
		event_region_container_control_window.hide()
		
	if !object or object.get_class() == "EditorDebuggerRemoteObject":
		if event_button:
			event_button.visible = false
			event_button.toggled.emit(false)
			enemy_spawn_region_button.visible = false
			enemy_spawn_region_button.toggled.emit(false)
			event_region_button.visible = false
			event_region_button.toggled.emit(false)
			var output_button: Button = event_button.get_parent().get_child(0)
			if output_button:
				output_button.toggled.emit(true)
		return

	if current_object and is_instance_valid(current_object) and "set_editing_events" in current_object:
		current_object.set_editing_events(false)
		current_object.set_editing_enemy_spawn_regions(false)
		current_object.set_editing_event_regions(false)

	current_object = object as RPGMap
	
	if current_object and !"set_editing_events" in current_object:
		current_object = null
		#return
	if event_button:
		if current_object:
			event_button.visible = true
			enemy_spawn_region_button.visible = true
			event_region_button.visible = true
			if "current_edit_button_pressed" in current_object and current_object.current_edit_button_pressed != -1:
				if current_object.current_edit_button_pressed == 0:
					event_button.set_pressed(false)
					event_button.set_pressed(true)
					event_button.toggled.emit(true)
				elif current_object.current_edit_button_pressed == 1:
					enemy_spawn_region_button.set_pressed(false)
					enemy_spawn_region_button.set_pressed(true)
					enemy_spawn_region_button.toggled.emit(true)
				else:
					event_region_button.set_pressed(false)
					event_region_button.set_pressed(true)
					event_region_button.toggled.emit(true)
			elif current_object.can_add_events:
				get_viewport().set_input_as_handled()
				event_button.visible = true
				enemy_spawn_region_button.visible = true
				event_region_button.visible = true
				event_button.set_pressed(false)
				event_button.set_pressed(true)
				event_button.toggled.emit(true)
		else:
			event_button.visible = false
			event_button.toggled.emit(false)
			enemy_spawn_region_button.visible = false
			enemy_spawn_region_button.toggled.emit(false)
			event_region_button.visible = true
			event_region_button.toggled.emit(false)
	
	if current_object:
		if Engine.is_editor_hint():
			if current_object.property_list_changed.is_connected(_on_map_property_changed):
				current_object.property_list_changed.disconnect(_on_map_property_changed)
			current_object.property_list_changed.connect(_on_map_property_changed.bind(current_object))
		var bottom_panel = event_button.get_parent()
		if bottom_panel:
			for child in bottom_panel.get_children():
				if child is Button and child.text == "TileSet":
					child.visible = false
	
	if (not event_button.is_pressed() and
		not enemy_spawn_region_button.is_pressed() and
		not event_region_button.is_pressed() and
		current_object and
		"current_edit_button_pressed" in current_object
	):
		current_object.current_edit_button_pressed = -1


func _on_map_property_changed(map: RPGMap) -> void:
	var rpg_map_info = get_node_or_null("/root/RPGMapsInfo")
	if rpg_map_info:
		rpg_map_info.fix_maps([map])


func _handles(object: Object) -> bool:
	if object is Resource:
		return false
		
	var result = object is RPGMap
	
	if "EditorDebuggerRemoteObject" in str(object):
		return false
	
	if object is Node and not object.is_inside_tree():
		return false
	
	if result:
		if object.has_method("set_force_update_shadow"):
			object.set_force_update_shadow(false)
			return true
		return false
	else:
		if event_button:
			event_button.visible = false
			event_button.toggled.emit(false)
		if enemy_spawn_region_button:
			enemy_spawn_region_button.visible = false
			enemy_spawn_region_button.toggled.emit(false)
		if event_region_button:
			event_region_button.visible = false
			event_region_button.toggled.emit(false)
		if current_object:
			current_object.set_force_update_shadow(true)
			current_object.set_editing_events(false)
			current_object.current_event = null
			current_object = null
		return false



func update_cursor_shape() -> void:
	var base_control: Control = EditorInterface.get_editor_viewport_2d().get_parent().get_parent()
	base_control.set_default_cursor_shape(current_cursor)


func _forward_canvas_force_draw_over_viewport(overlay: Control) -> void:
	var viewport_2d_size = get_editor_interface().get_editor_viewport_2d().size
	var font = overlay.get_theme_default_font()
	var font_size = overlay.get_theme_default_font_size()
	var align = HORIZONTAL_ALIGNMENT_LEFT
	var text: String
	
	# Draw Map ID
	
	if current_object:
		text = "Map ID: %s" % current_object.internal_id
		var s = font.get_string_size(text, align, -1, font_size)
		var p = Vector2(viewport_2d_size.x - s.x - 20, font.get_ascent() + s.y)
		overlay.draw_string_outline(font, p, text, align, -1, font_size, 2, Color.BLACK)
		overlay.draw_string(font, p, text, align, -1, font_size, Color.WHITE)
	
	if current_edit_mode != MODE.NONE and current_object:
		# draw current tile coords
		text = str(current_tile_pos)
		if current_edit_mode == MODE.EVENT:
			var event_under_mouse = current_object.get_event_in(current_tile_pos)
			if event_under_mouse != null:
				if current_edit_mode == MODE.EVENT:
					var event_name = " | " + str(event_under_mouse.id).pad_zeros(4) + ":" + event_under_mouse.name
					text += event_name
				elif current_edit_mode == MODE.ENEMY_SPAWN or MODE.EVENT_REGION:
					var rect_name = ""
					text += rect_name
			else:
				var system = get_node_or_null("/root/RPGSYSTEM")
				if system:
					var map_id = current_object.internal_id
					var ids = [
						"player_start_position",
						"land_transport_start_position",
						"sea_transport_start_position",
						"air_transport_start_position",
					]
					for id: String in ids:
						var data: RPGMapPosition = system.database.system.get(id)
						if data and data.map_id == map_id and data.position == current_tile_pos:
							text += " | " + id.replace("_", " ").capitalize()
							break
		elif current_edit_mode == MODE.ENEMY_SPAWN:
			var region = current_object.get_region_in(current_tile_pos)
			if region:
				text += " | " + region.to_string()
		elif current_edit_mode == MODE.EVENT_REGION:
			var region = current_object.get_event_region_in(current_tile_pos)
			if region:
				text += " | " + region.to_string()
		var p = Vector2(20, viewport_2d_size.y - font.get_ascent())
		overlay.draw_string_outline(font, p, text, align, -1, font_size, 2, Color.BLACK)
		overlay.draw_string(font, p, text, align, -1, font_size, Color.WHITE)


func find_viewport_2d(node: Node, recursive_level):
	if node.get_class() == "CanvasItemEditor":
		return node.get_child(1).get_child(0).get_child(0).get_child(0).get_child(0)
	else:
		recursive_level += 1
		if recursive_level > 15:
			return null
		for child in node.get_children():
			var result = find_viewport_2d(child, recursive_level)
			if result != null:
				return result


func _input(event: InputEvent) -> void:
	if !current_object or EditorInterface.get_script_editor().is_visible_in_tree() or (
		!current_object.editing_enemy_spawn_region and !current_object.editing_event_region
	):
		return
	
	var current_data = current_object.regions if current_object.editing_enemy_spawn_region else current_object.event_regions

	if event is InputEventMouseMotion and !is_resizing:
		var mouse_pos = current_object.get_local_mouse_position()
		current_cursor = RESIZE_CURSORS.arrow
		
		for region in current_data:
			var handle = get_resize_handle(region, mouse_pos)
			if handle != "" and handle != "inside":
				current_cursor = RESIZE_CURSORS[handle]
				get_viewport().set_input_as_handled()
				break
			elif handle == "inside":
				current_cursor = RESIZE_CURSORS.move
		
		update_cursor_shape()
	
	elif event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.pressed:
				var mouse_pos = current_object.get_local_mouse_position()
				for region in current_data:
					resize_handle = get_resize_handle(region, mouse_pos)
					if resize_handle != "" and resize_handle != "inside":
						is_resizing = true
						resize_start_pos = mouse_pos
						resize_start_rect = region.rect
						if current_object.editing_enemy_spawn_region:
							current_enemy_spawn_region = region
							current_object.current_enemy_spawn_region = region
							current_object.region_selected = region
						else:
							current_event_region = region
							current_object.current_event_region = region
							current_object.event_region_selected = region
						break
			else:
				is_resizing = false
				resize_handle = ""
				if current_enemy_spawn_region:
					current_object.current_enemy_spawn_region = null
					current_object.update_region(current_enemy_spawn_region)
				elif current_event_region:
					current_object.current_event_region = null
					current_object.update_event_region(current_event_region)
	
	elif is_resizing and event is InputEventMouseMotion:
		var mouse_pos = current_object.get_local_mouse_position()
		var delta = Vector2i((mouse_pos - resize_start_pos) / Vector2(current_object.tile_size))
		var new_rect: Rect2i = resize_start_rect
		
		match resize_handle:
			"top_left":
				new_rect.position += delta
				new_rect.size -= delta
			"top_right":
				new_rect.position.y += delta.y
				new_rect.size.x += delta.x
				new_rect.size.y -= delta.y
			"bottom_left":
				new_rect.position.x += delta.x
				new_rect.size.x -= delta.x
				new_rect.size.y += delta.y
			"bottom_right":
				new_rect.size += delta
			"left":
				new_rect.position.x += delta.x
				new_rect.size.x -= delta.x
			"right":
				new_rect.size.x += delta.x
			"top":
				new_rect.position.y += delta.y
				new_rect.size.y -= delta.y
			"bottom":
				new_rect.size.y += delta.y
		
		new_rect = new_rect.abs()
		new_rect.size = new_rect.size.max(Vector2i.ONE)
		if current_enemy_spawn_region:
			current_enemy_spawn_region.rect = new_rect.abs()
			current_object.update_region(current_enemy_spawn_region)
			if enemy_spawn_container_control:
				enemy_spawn_container_control.select(current_enemy_spawn_region.id, false, true)
		elif current_event_region:
			current_event_region.rect = new_rect.abs()
			current_object.update_event_region(current_event_region)
			if event_region_container_control:
				event_region_container_control.select(current_event_region.id, false, true)
			
		update_cursor_shape()
	
	if is_resizing:
		get_viewport().set_input_as_handled()


func get_resize_handle(region: Variant, mouse_pos: Vector2) -> String:
	var tile_size = current_object.tile_size
	var rect = Rect2(region.rect.position * tile_size, region.rect.size * tile_size)
	var handle_size = Vector2(RESIZE_HANDLE_SIZE, RESIZE_HANDLE_SIZE)
	
	if Rect2(rect.position, handle_size).has_point(mouse_pos):
		return "top_left"
	elif Rect2(rect.position + Vector2(rect.size.x - RESIZE_HANDLE_SIZE, 0), handle_size).has_point(mouse_pos):
		return "top_right"
	elif Rect2(rect.position + Vector2(0, rect.size.y - RESIZE_HANDLE_SIZE), handle_size).has_point(mouse_pos):
		return "bottom_left"
	elif Rect2(rect.end - handle_size, handle_size).has_point(mouse_pos):
		return "bottom_right"
	elif Rect2(rect.position, Vector2(RESIZE_HANDLE_SIZE, rect.size.y)).has_point(mouse_pos):
		return "left"
	elif Rect2(rect.position + Vector2(rect.size.x - RESIZE_HANDLE_SIZE, 0), Vector2(RESIZE_HANDLE_SIZE, rect.size.y)).has_point(mouse_pos):
		return "right"
	elif Rect2(rect.position, Vector2(rect.size.x, RESIZE_HANDLE_SIZE)).has_point(mouse_pos):
		return "top"
	elif Rect2(rect.position + Vector2(0, rect.size.y - RESIZE_HANDLE_SIZE), Vector2(rect.size.x, RESIZE_HANDLE_SIZE)).has_point(mouse_pos):
		return "bottom"
	elif rect.has_point(mouse_pos):
		return "inside"
	
	return ""


func _forward_canvas_gui_input(event: InputEvent) -> bool:
	if tile_popup_menu.visible or region_popup_menu.visible or is_resizing:
		return false

	if current_edit_mode != MODE.NONE and current_object:
		var input_handled: bool = false
		if event is InputEventMouseMotion:
			current_cursor = RESIZE_CURSORS.arrow
			if current_object.is_mouse_over_event() or is_mouse_over_start_positions():
				current_cursor = RESIZE_CURSORS.move
			var pos = current_object.get_local_mouse_position()
			update_cursor_shape()
			current_tile_pos = current_object.local_to_map(pos)
			if dragging_event or dragging_start_position:
				set_cursor_position()
				if cursor and is_instance_valid(cursor):
					if can_place_event_in(current_tile_pos):
						cursor.modulate = Color.WHITE
					else:
						cursor.modulate = Color("#66000044")
			elif dragging_enemy_spawn_region:
				update_drawing_region()
			elif dragging_event_region:
				update_drawing_event_region()
			elif moving_enemy_spawn_region:
				update_moving_region(event.position)
			elif moving_event_region:
				update_moving_event_region(event.position)
				
			input_handled = true
		elif event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
			if event.is_pressed():
				if current_edit_mode == MODE.EVENT:
					var _current_event = current_object.get_event_in(current_tile_pos)
					
					if can_place_event_in(current_tile_pos) or _current_event:
						var result = add_event_in(current_tile_pos) if !_current_event and event.is_double_click() else false
						if result:
							get_editor_interface().mark_scene_as_unsaved()
							if event_container_control:
								event_container_control.refresh(true)
								var ev: RPGEvent = current_object.events.get_event_in(current_tile_pos)
								event_container_control.select(ev.id, true, true)
								current_cursor = RESIZE_CURSORS.move
						elif _current_event:
							if event.is_double_click():
								show_edit_event_dialog()
							else:
								current_object.select_event(Vector2i(_current_event.x, _current_event.y))
								dragging_event = _current_event
								create_cursor()
								set_cursor_position()
								if event_container_control:
									event_container_control.select(dragging_event.id, false, true)
							current_cursor = RESIZE_CURSORS.move
					else:
						var start_position = get_start_position_under_mouse()
						if start_position:
							current_object.current_start_position = start_position
							if event_container_control:
								event_container_control.refresh(true)
							dragging_start_position = start_position
							create_cursor()
							set_cursor_position()
							current_cursor = RESIZE_CURSORS.move
					update_cursor_shape()
									
				elif current_edit_mode == MODE.ENEMY_SPAWN:
					var region: EnemySpawnRegion = get_region_in(current_tile_pos)
					if can_place_event_in(current_tile_pos) or region:
						if region:
							moving_enemy_spawn_region = region.duplicate()
							current_object.current_enemy_spawn_region = moving_enemy_spawn_region
							current_object.region_selected = region
							drawing_region_start_position = event.position
							current_region_position = moving_enemy_spawn_region.rect.position
							if enemy_spawn_container_control:
								enemy_spawn_container_control.select(moving_enemy_spawn_region.id, false, true)
							if event.is_double_click():
								show_edit_region_dialog()
						else:
							dragging_enemy_spawn_region = EnemySpawnRegion.new()
							current_object.current_enemy_spawn_region = dragging_enemy_spawn_region
							drawing_region_start_position = current_tile_pos
							update_drawing_region()
				
				elif current_edit_mode == MODE.EVENT_REGION:
					var region: EventRegion = get_event_region_in(current_tile_pos)
					if can_place_event_in(current_tile_pos) or region:
						if region:
							moving_event_region = region.duplicate()
							current_object.current_event_region = moving_event_region
							current_object.event_region_selected = region
							drawing_region_start_position = event.position
							current_region_position = moving_event_region.rect.position
							if event_region_container_control:
								event_region_container_control.select(moving_event_region.id, false, true)
							if event.is_double_click():
								show_edit_event_region_dialog()
						else:
							dragging_event_region = EventRegion.new()
							current_object.current_event_region = dragging_event_region
							drawing_region_start_position = current_tile_pos
							update_drawing_event_region()
						
			elif dragging_event:
				var pos = current_object.get_local_mouse_position()
				var real_pos = current_object.local_to_map(pos)
				if current_object.events.is_place_free_in(real_pos) and can_place_event_in(real_pos):
					current_tile_pos = current_object.local_to_map(pos)
					dragging_event.x = current_tile_pos.x
					dragging_event.y = current_tile_pos.y
					current_object.queue_redraw()
					get_editor_interface().mark_scene_as_unsaved()
					if event_container_control:
						event_container_control.refresh(true)
					current_cursor = RESIZE_CURSORS.arrow
					if current_object.is_mouse_over_event():
						current_cursor = RESIZE_CURSORS.move
					update_cursor_shape()
					current_object.property_list_changed.emit()
						
				dragging_event = null
				destroy_cursor()
				
			elif dragging_enemy_spawn_region:
				var region: EnemySpawnRegion = current_object.add_region(dragging_enemy_spawn_region)
				if enemy_spawn_container_control:
					enemy_spawn_container_control.refresh(true)
					enemy_spawn_container_control.select(region.id, true, true)
				current_object.current_enemy_spawn_region = null
				dragging_enemy_spawn_region = null
				get_editor_interface().mark_scene_as_unsaved()
				current_object.property_list_changed.emit()
			
			elif dragging_event_region:
				var region: EventRegion = current_object.add_event_region(dragging_event_region)
				if event_region_container_control:
					event_region_container_control.refresh(true)
					event_region_container_control.select(region.id, true, true)
				current_object.current_event_region = null
				dragging_event_region = null
				get_editor_interface().mark_scene_as_unsaved()
				current_object.property_list_changed.emit()
			
			elif moving_enemy_spawn_region:
				current_object.update_region(moving_enemy_spawn_region)
				if enemy_spawn_container_control:
					enemy_spawn_container_control.select(moving_enemy_spawn_region.id, true, true)
				current_object.current_enemy_spawn_region = null
				moving_enemy_spawn_region = null
				get_editor_interface().mark_scene_as_unsaved()
				current_object.property_list_changed.emit()
			
			elif moving_event_region:
				current_object.update_event_region(moving_event_region)
				if event_region_container_control:
					event_region_container_control.select(moving_event_region.id, true, true)
				current_object.current_event_region = null
				moving_event_region = null
				get_editor_interface().mark_scene_as_unsaved()
				current_object.property_list_changed.emit()

			elif dragging_start_position:
				var pos = current_object.get_local_mouse_position()
				var real_pos = current_object.local_to_map(pos)
				if current_object.events.is_place_free_in(real_pos) and can_place_event_in(real_pos):
					dragging_start_position.position = current_tile_pos
					current_object.queue_redraw()
					get_editor_interface().mark_scene_as_unsaved()
					if event_container_control:
						event_container_control.refresh(true)
					current_cursor = RESIZE_CURSORS.arrow
					if current_object.is_mouse_over_event():
						current_cursor = RESIZE_CURSORS.move
					update_cursor_shape()
					current_object.property_list_changed.emit()
						
				dragging_start_position = RPGMapPosition.new()
				current_object.current_start_position = RPGMapPosition.new()
				if event_container_control:
					event_container_control.refresh(true)
				destroy_cursor()

			input_handled = true
			
				
		elif current_edit_mode == MODE.EVENT:
			if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_RIGHT and event.is_pressed():
				var pos = current_object.get_local_mouse_position()
				pos = current_object.local_to_map(pos)
				if can_place_event_in(pos):
					var ev = current_object.get_event_in(pos)
					if ev and event_container_control:
						event_container_control.select(ev.id, true, true)
					show_tile_popup_menu(event.global_position)
				elif get_start_position_under_mouse():
					show_start_position_popup_menu(event.global_position)
				input_handled = true
			elif event is InputEventKey and event.is_pressed():
				if event.keycode == KEY_ENTER:
					show_edit_event_dialog()
					input_handled = true
				elif event.is_ctrl_pressed():
					if event.keycode == KEY_C:
						copy_tile_into_clipboard()
						input_handled = true
					elif event.keycode == KEY_X:
						copy_tile_into_clipboard()
						remove_tile()
						input_handled = true
					elif event.keycode == KEY_V:
						paste_tile()
						var paste_event_id = current_object.get_last_event_added()
						if event_container_control:
							event_container_control.select(paste_event_id, true, true)
						input_handled = true
		
		elif current_edit_mode == MODE.ENEMY_SPAWN or current_edit_mode == MODE.EVENT_REGION:
			if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_RIGHT and event.is_pressed():
				var pos = current_object.get_local_mouse_position()
				pos = current_object.local_to_map(pos)
				if current_edit_mode == MODE.ENEMY_SPAWN:
					var region = current_object.get_region_in(pos)
					if region and enemy_spawn_container_control:
						enemy_spawn_container_control.select(region.id, true, true)
				else:
					var region = current_object.get_event_region_in(pos)
					if region and event_region_container_control:
						event_region_container_control.select(region.id, true, true)
				show_region_popup_menu(event.global_position)
				input_handled = true
			elif event is InputEventKey and event.is_pressed():
				if event.keycode == KEY_ENTER and current_object.region_selected:
					show_edit_region_dialog()
					input_handled = true
				elif event.is_ctrl_pressed():
					if event.keycode == KEY_C:
						copy_region_into_clipboard()
						input_handled = true
					elif event.keycode == KEY_X:
						copy_region_into_clipboard(current_object.region_selected)
						remove_region(current_object.region_selected)
						input_handled = true
					elif event.keycode == KEY_V:
						paste_region()
						if enemy_spawn_container_control:
							enemy_spawn_container_control.select(current_object.regions.size() - 1, true, true)
						input_handled = true
		
		if input_handled:
			get_viewport().set_input_as_handled()
			update_overlays()
			return true
		
	return false


func is_mouse_over_start_positions() -> bool:
	var system = get_node_or_null("/root/RPGSYSTEM")
	if !system:
		return false
	var map_id = current_object.internal_id
	var ids = [
		"player_start_position",
		"land_transport_start_position",
		"sea_transport_start_position",
		"air_transport_start_position",
	]
	for id: String in ids:
		var data: RPGMapPosition = system.database.system.get(id)
		if data and data.map_id == map_id and data.position == current_tile_pos:
			return true
	
	return false


func get_start_position_under_mouse() -> RPGMapPosition:
	var system = get_node_or_null("/root/RPGSYSTEM")
	if !system:
		return null
	var map_id = current_object.internal_id
	var ids = [
		"player_start_position",
		"land_transport_start_position",
		"sea_transport_start_position",
		"air_transport_start_position",
	]
	for id: String in ids:
		var data: RPGMapPosition = system.database.system.get(id)
		if data and data.map_id == map_id and data.position == current_tile_pos:
			return data
	
	return null


func update_drawing_region() -> void:
	var top_left = Vector2i(
		min(drawing_region_start_position.x, current_tile_pos.x),
		min(drawing_region_start_position.y, current_tile_pos.y)
	)
	var bottom_right = Vector2i(
		max(drawing_region_start_position.x, current_tile_pos.x) + 1,
		max(drawing_region_start_position.y, current_tile_pos.y) + 1
	)
	
	dragging_enemy_spawn_region.rect = Rect2i(top_left, bottom_right - top_left)
	dragging_enemy_spawn_region.rect.size = dragging_enemy_spawn_region.rect.size.max(Vector2i.ONE)
	
	current_object.refresh_canvas()


func update_drawing_event_region() -> void:
	var top_left = Vector2i(
		min(drawing_region_start_position.x, current_tile_pos.x),
		min(drawing_region_start_position.y, current_tile_pos.y)
	)
	var bottom_right = Vector2i(
		max(drawing_region_start_position.x, current_tile_pos.x) + 1,
		max(drawing_region_start_position.y, current_tile_pos.y) + 1
	)
	
	dragging_event_region.rect = Rect2i(top_left, bottom_right - top_left)
	dragging_event_region.rect.size = dragging_event_region.rect.size.max(Vector2i.ONE)
	
	current_object.refresh_canvas()


func update_moving_region(pos: Vector2i) -> void:
	var viewport = EditorInterface.get_editor_viewport_2d()
	var scale = viewport.get_final_transform().y.y
	var target: Vector2i = (pos - Vector2i(drawing_region_start_position)) / scale
	var dest: Vector2i = target / current_object.tile_size
	
	moving_enemy_spawn_region.rect.position = current_region_position + dest
	
	current_object.refresh_canvas()


func update_moving_event_region(pos: Vector2i) -> void:
	var viewport = EditorInterface.get_editor_viewport_2d()
	var scale = viewport.get_final_transform().y.y
	var target: Vector2i = (pos - Vector2i(drawing_region_start_position)) / scale
	var dest: Vector2i = target / current_object.tile_size
	
	moving_event_region.rect.position = current_region_position + dest
	
	current_object.refresh_canvas()


func show_tile_popup_menu(pos: Vector2) -> void:
	if current_object:
		create_selected_cursor()
		await get_tree().process_frame
		
		current_event = current_object.get_event_in(current_tile_pos)

		if !current_event:
			tile_popup_menu.set_item_text(0, "Create New Item")
		else:
			tile_popup_menu.set_item_text(0, "Edit Item")
		
		tile_popup_menu.set_item_disabled(2, !current_event)
		tile_popup_menu.set_item_disabled(3, !current_event)
		tile_popup_menu.set_item_disabled(4, current_event != null or !clipboard.has("event"))
		tile_popup_menu.set_item_disabled(5, !current_event)
		tile_popup_menu.set_item_disabled(7, current_event != null)
		
		var start_position_in_clipboard = clipboard.get("start_position", {})
		var submenu: PopupMenu = tile_popup_menu.get_child(0)
		if !start_position_in_clipboard.is_empty():
			submenu.set_item_disabled(5, false)
			var start_position_name = "Paste From Clipboard (%s)" % (
				"Player" if start_position_in_clipboard == "player_start_position" else
				"land Transport" if start_position_in_clipboard == "land_transport_start_position" else
				"Sea Transport" if start_position_in_clipboard == "sea_transport_start_position" else
				"Air Transport" if start_position_in_clipboard == "air_transport_start_position" else
				""
			)
			submenu.set_item_text(5, start_position_name)
		else:
			submenu.set_item_disabled(5, true)
			
		
		if current_event:
			current_object.select_event(Vector2i(current_event.x, current_event.y))
		
		var real_pos = pos + Vector2(-20, 5)
		if real_pos.x < 20:
			real_pos.x = 20
		elif real_pos.x > get_viewport().size.x - tile_popup_menu.size.x - 20:
			real_pos.x = get_viewport().size.x - tile_popup_menu.size.x - 20
		if real_pos.y < 20:
			real_pos.y = 20
		elif real_pos.y > get_viewport().size.y - tile_popup_menu.size.y - 20:
			real_pos.y = get_viewport().size.y - tile_popup_menu.size.y - 20
		tile_popup_menu.position = real_pos
		
		tile_popup_menu.show()


func show_region_popup_menu(pos: Vector2) -> void:
	var region = get_region_in(current_tile_pos) if current_edit_mode == MODE.ENEMY_SPAWN else get_event_region_in(current_tile_pos)
	
	var clipboard_id = "enemy_spawn_region" if current_edit_mode == MODE.ENEMY_SPAWN else "event_region"
	
	region_popup_menu.set_item_disabled(0, region == null)
	region_popup_menu.set_item_disabled(1, false)
	region_popup_menu.set_item_disabled(2, region == null)
	region_popup_menu.set_item_disabled(4, region == null)
	region_popup_menu.set_item_disabled(5, region == null)
	region_popup_menu.set_item_disabled(6, !clipboard.has(clipboard_id) or region)
	
	var real_pos = pos + Vector2(-20, 5)
	if real_pos.x < 20:
		real_pos.x = 20
	elif real_pos.x > get_viewport().size.x - region_popup_menu.size.x - 20:
		real_pos.x = get_viewport().size.x - region_popup_menu.size.x - 20
	if real_pos.y < 20:
		real_pos.y = 20
	elif real_pos.y > get_viewport().size.y - region_popup_menu.size.y - 20:
		real_pos.y = get_viewport().size.y - region_popup_menu.size.y - 20
	region_popup_menu.position = real_pos
	
	region_popup_menu.show()


func show_start_position_popup_menu(pos: Vector2) -> void:
	if current_object:
		create_selected_cursor()
		await get_tree().process_frame
		
		current_start_position = get_start_position_under_mouse()
		
		if current_event:
			current_object.select_event(Vector2i(current_event.x, current_event.y))
		
		var real_pos = pos + Vector2(-20, 5)
		if real_pos.x < 20:
			real_pos.x = 20
		elif real_pos.x > get_viewport().size.x - start_position_popup_menu.size.x - 20:
			real_pos.x = get_viewport().size.x - start_position_popup_menu.size.x - 20
		if real_pos.y < 20:
			real_pos.y = 20
		elif real_pos.y > get_viewport().size.y - start_position_popup_menu.size.y - 20:
			real_pos.y = get_viewport().size.y - start_position_popup_menu.size.y - 20
		start_position_popup_menu.position = real_pos
		
		start_position_popup_menu.show()


func _on_tile_popup_menu_index_pressed(index: int) -> void:
	if index == 0: # Create\Edit tile
		if !current_event:
			create_new_tile() # Create new tile
		else:
			show_edit_event_dialog() # Edit tile
	elif index == 2: # Cut tile
		copy_tile_into_clipboard()
		remove_tile()
	elif index == 3: # Copy tile
		copy_tile_into_clipboard()
	elif index == 4: # Paste tile
		paste_tile()
	elif index == 5: # Remove tile
		remove_tile()


func _on_tile_subpopup_menu1_index_pressed(index: int) -> void:
	if !current_object:
		return
	
	var system = get_node_or_null("/root/RPGSYSTEM")
	if !system:
		return
	
	var map_id = current_object.internal_id
	var info = RPGMapPosition.new(map_id, current_tile_pos)
		
	if index == 0: # Start Player Position
		system.database.system.player_start_position = info
	elif index == 1: # Start Land Transport Position
		system.database.system.land_transport_start_position = info
	elif index == 2: # Start Sea Transport Position
		system.database.system.sea_transport_start_position = info
	elif index == 3: # Start Air Transport Position
		system.database.system.air_transport_start_position = info
	elif index == 5: # Paste Start Position
		paste_start_position()
	
	if event_container_control:
		event_container_control.refresh(true)
	
	current_object.property_list_changed.emit()


func _on_preset_pressed(index: int) -> void:
	pass


func _on_region_popup_menu_index_pressed(index: int) -> void:
	if current_edit_mode == MODE.ENEMY_SPAWN:
		if index == 0: # Edit region
			show_edit_region_dialog()
		elif index == 2: # Remove region
			remove_region(current_object.region_selected)
		elif index == 4: # Cut region
			copy_region_into_clipboard()
			remove_region(current_object.region_selected)
		elif index == 5: # Copy region
			copy_region_into_clipboard()
		elif index == 6: # Paste region
			paste_region()
	else:
		if index == 0: # Edit region
			show_edit_event_region_dialog()
		elif index == 2: # Remove region
			remove_event_region(current_object.event_region_selected)
		elif index == 4: # Cut region
			copy_event_region_into_clipboard()
			remove_event_region(current_object.event_region_selected)
		elif index == 5: # Copy region
			copy_event_region_into_clipboard()
		elif index == 6: # Paste region
			paste_event_region()


func _on_start_position_popup_menu_index_pressed(index: int) -> void:
	if index == 0: # Cut start position
		copy_start_position_into_clipboard()
		remove_start_position()
	elif index == 1: # Copy start position
		copy_start_position_into_clipboard()
	elif index == 2: # Remove start position
		remove_start_position()
	


func copy_start_position_into_clipboard() -> void:
	if current_start_position:
		var node = get_node_or_null("/root/RPGSYSTEM")
		if node:
			var system = node.database.system
			var data: Dictionary
			var key: String
			if system.player_start_position == current_start_position:
				key = "player_start_position"
			elif system.land_transport_start_position == current_start_position:
				key = "land_transport_start_position"
			elif system.sea_transport_start_position == current_start_position:
				key = "sea_transport_start_position"
			elif system.air_transport_start_position == current_start_position:
				key = "air_transport_start_position"
			clipboard.start_position = key
	
	destroy_selected_cursor()


func paste_start_position() -> void:
	var start_position_key = clipboard.get("start_position")
	if current_object and start_position_key:
		var data: RPGMapPosition = RPGSYSTEM.database.system.get(start_position_key)
		data.map_id = current_object.internal_id
		data.position = current_tile_pos
		if event_container_control:
			event_container_control.refresh(true)
	
	destroy_selected_cursor()


func remove_start_position() -> void:
	if current_start_position:
		current_start_position.clear()
		
		if current_object:
			current_object.current_start_position = RPGMapPosition.new()
		
		if event_container_control:
			event_container_control.refresh(true)
		
		destroy_selected_cursor()
		
		current_object.property_list_changed.emit()


func create_new_tile() -> void:
	var result = add_event_in(current_tile_pos)
	if result:
		get_editor_interface().mark_scene_as_unsaved()
		if event_container_control:
			event_container_control.refresh(true)
		current_object.select_event(current_tile_pos)


func copy_tile_into_clipboard(default_region: EnemySpawnRegion = null) -> void:
	var event = current_object.get_event_in(current_tile_pos) if !default_region else default_region
	if event:
		clipboard["event"] = event.clone(true)


func copy_region_into_clipboard(default_region: EnemySpawnRegion = null) -> void:
	var region = current_object.region_selected if !default_region else default_region
	if region:
		clipboard["enemy_spawn_region"] = region.clone(true)


func copy_event_region_into_clipboard(default_region: EventRegion = null) -> void:
	var region = current_object.event_region_selected if !default_region else default_region
	if region:
		clipboard["event_region"] = region.clone(true)


func paste_tile() -> void:
	if clipboard.has("event"):
		var result = current_object.paste_event_in(current_tile_pos, clipboard["event"].clone(true))
		if result:
			get_editor_interface().mark_scene_as_unsaved()
			if event_container_control:
				focus_tile_is_enabled = false
				event_container_control.refresh(true)
				focus_tile_is_enabled = true
			current_object.property_list_changed.emit()


func paste_region() -> void:
	if clipboard.has("enemy_spawn_region"):
		var region: EnemySpawnRegion = clipboard["enemy_spawn_region"]
		var new_region = region.clone(true)
		var result = current_object.paste_region_in(current_tile_pos, new_region)
		if result:
			get_editor_interface().mark_scene_as_unsaved()
			if enemy_spawn_container_control:
				focus_tile_is_enabled = false
				enemy_spawn_container_control.refresh(true)
				enemy_spawn_container_control.select(new_region.id, true, true)
				focus_tile_is_enabled = true
			current_object.property_list_changed.emit()


func paste_event_region() -> void:
	if clipboard.has("event_region"):
		var region: EventRegion = clipboard["event_region"]
		var new_region = region.clone(true)
		var result = current_object.paste_event_region_in(current_tile_pos, new_region)
		if result:
			get_editor_interface().mark_scene_as_unsaved()
			if event_region_container_control:
				focus_tile_is_enabled = false
				event_region_container_control.refresh(true)
				event_region_container_control.select(new_region.id, true, true)
				focus_tile_is_enabled = true
			current_object.property_list_changed.emit()


func remove_tile():
	current_tile_pos = Vector2(current_object.current_event.x, current_object.current_event.y)
	if current_object.remove_event_in(current_tile_pos):
		get_editor_interface().mark_scene_as_unsaved()
		if event_container_control:
			focus_tile_is_enabled = false
			event_container_control.refresh(true)
			focus_tile_is_enabled = true
		current_object.property_list_changed.emit()


func remove_region(default_region: EnemySpawnRegion = null):
	var removed: bool = false
	if default_region:
		current_object.remove_region(default_region)
		removed = true
	current_tile_pos = current_enemy_spawn_region.rect.position
	if current_object.remove_region_in(current_tile_pos):
		removed = true
	
	if removed:
		get_editor_interface().mark_scene_as_unsaved()
		focus_tile_is_enabled = false
		if enemy_spawn_container_control:
			enemy_spawn_container_control.refresh(true)
		if current_object.regions.size() == 0:
			current_object.region_selected = null
		focus_tile_is_enabled = true
		current_object.property_list_changed.emit()


func remove_event_region(default_region: EventRegion = null):
	var removed: bool = false
	if default_region:
		current_object.remove_event_region(default_region)
		removed = true
	current_tile_pos = current_event_region.rect.position
	if current_object.remove_event_region_in(current_tile_pos):
		removed = true
	
	if removed:
		get_editor_interface().mark_scene_as_unsaved()
		focus_tile_is_enabled = false
		if event_region_container_control:
			event_region_container_control.refresh(true)
		if current_object.event_regions.size() == 0:
			current_object.event_region_selected = null
		focus_tile_is_enabled = true
		current_object.property_list_changed.emit()


func _on_tile_popup_menu_visibility_changed() -> void:
	if !tile_popup_menu.visible:
		tile_popup_menu.set_item_disabled(8, true)
		destroy_selected_cursor()


func _on_region_popup_menu_visibility_changed() -> void:
	pass


func show_edit_event_dialog() -> void:
	current_event = current_object.get_event_in(current_tile_pos)
	if !current_event or !current_object:
		return
	var path = "res://addons/CustomControls/Dialogs/edit_event_dialog.tscn"
	
	var dialog = RPGDialogFunctions.open_dialog(path, RPGDialogFunctions.OPEN_MODE.CENTERED_ON_MOUSE)
	dialog.resource_previewer = EditorInterface.get_resource_previewer()
	dialog.clipboard = clipboard
	dialog.set_event(current_event)
	dialog.set_events(current_object.events)
	dialog.changed.connect(get_editor_interface().mark_scene_as_unsaved)
	dialog.size_changed.connect(_on_dialog_size_changed.bind(path, dialog))
	dialog.tree_exited.connect(_on_dialog_tree_exited)
	dialog.tree_exiting.connect(
		func():
			FileCache.options.edit_event_dialog = {"position": dialog.position, "size": dialog.size}
	)
	
	dialog.setup()

	var state = FileCache.options.get("edit_event_dialog", null)
	if !state:
		var s = Vector2i(DisplayServer.screen_get_size() * 0.85)
		dialog.size = s
		dialog.position = DisplayServer.screen_get_size() / 2 - dialog.size / 2
	else:
		dialog.size = state.size
		dialog.position = state.position


func _on_dialog_tree_exited() -> void:
	if event_container_control:
		event_container_control.refresh(true)


func _on_dialog_size_changed(path: String, dialog: Window) -> void:
	dialog_sizes[path] = dialog.size


func show_edit_region_dialog() -> void:
	current_enemy_spawn_region = current_object.region_selected
	if !current_enemy_spawn_region or !current_object:
		return
	var path = "res://addons/CustomControls/Dialogs/edit_enemy_spawn_region_dialog.tscn"
	
	var dialog_size = null
	if dialog_sizes.has(path):
		dialog_size = dialog_sizes[path]
	var dialog = RPGDialogFunctions.open_dialog(path, RPGDialogFunctions.OPEN_MODE.CENTERED_ON_MOUSE, dialog_size)
	dialog.region_changed.connect(_on_region_changed_in_dialog)
	dialog.size_changed.connect(_on_region_dialog_size_changed.bind(path, dialog))
	dialog.tree_exited.connect(_on_region_dialog_tree_exited)

	dialog.set_region(current_enemy_spawn_region)


func _on_region_changed_in_dialog(_region: EnemySpawnRegion) -> void:
	get_editor_interface().mark_scene_as_unsaved()
	current_object.refresh_canvas()
	current_object.property_list_changed.emit()


func _on_region_dialog_tree_exited() -> void:
	moving_enemy_spawn_region = null
	current_object.current_enemy_spawn_region = null
	if enemy_spawn_container_control:
		enemy_spawn_container_control.refresh(true)


func _on_region_dialog_size_changed(path: String, dialog: Window) -> void:
	dialog_sizes[path] = dialog.size


func show_edit_event_region_dialog() -> void:
	current_event_region = current_object.event_region_selected
	if !current_event_region or !current_object:
		return
	var path = "res://addons/CustomControls/Dialogs/edit_event_region_dialog.tscn"
	
	var dialog_size = null
	if dialog_sizes.has(path):
		dialog_size = dialog_sizes[path]
	var dialog = RPGDialogFunctions.open_dialog(path, RPGDialogFunctions.OPEN_MODE.CENTERED_ON_MOUSE, dialog_size)
	dialog.region_changed.connect(_on_event_region_changed_in_dialog)
	dialog.size_changed.connect(_on_event_region_dialog_size_changed.bind(path, dialog))
	dialog.tree_exited.connect(_on_event_region_dialog_tree_exited)

	dialog.set_events(current_object.events.get_events())
	dialog.set_region(current_event_region)


func _on_event_region_changed_in_dialog(_region: EventRegion) -> void:
	get_editor_interface().mark_scene_as_unsaved()
	current_object.refresh_canvas()
	current_object.property_list_changed.emit()


func _on_event_region_dialog_tree_exited() -> void:
	moving_enemy_spawn_region = null
	current_object.current_event_region = null
	if enemy_spawn_container_control and enemy_spawn_container_control.visible:
		enemy_spawn_container_control.refresh(true)
	elif event_region_container_control and event_region_container_control.visible:
		event_region_container_control.refresh(true)


func _on_event_region_dialog_size_changed(path: String, dialog: Window) -> void:
	dialog_sizes[path] = dialog.size


func re_focus_dialog(dialog: Window) -> void:
	dialog.request_attention()
	await get_tree().process_frame
	dialog.grab_focus()


func create_cursor() -> void:
	cursor = preload("res://addons/RPGMap/Scenes/tilemap_cursor.tscn").instantiate()
	cursor.size = current_object.tile_size + Vector2i(2, 2)
	current_object.add_child(cursor)


func create_selected_cursor() -> void:
	selected_cursor = preload("res://addons/RPGMap/Scenes/tilemap_cursor_selected.tscn").instantiate()
	selected_cursor.size = current_object.tile_size + Vector2i(2, 2)
	current_object.add_child(selected_cursor)
	var pos = Vector2i(current_object.map_to_local(current_tile_pos)) - Vector2i.ONE
	selected_cursor.position = pos


func set_cursor_position() -> void:
	if cursor and is_instance_valid(cursor):
		var pos = Vector2i(current_object.map_to_local(current_tile_pos)) - Vector2i.ONE
		cursor.position = pos


func destroy_cursor() -> void:
	if cursor and is_instance_valid(cursor):
		cursor.queue_free()


func destroy_selected_cursor() -> void:
	selected_cursor.queue_free()


func add_event_in(pos: Vector2i) -> bool:
	var result = current_object.add_event_in(pos)
	return result


func get_region_in(pos: Vector2i) -> EnemySpawnRegion:
	var region = current_object.get_region_in(pos)
	return region


func get_event_region_in(pos: Vector2i) -> EventRegion:
	var region = current_object.get_event_region_in(pos)
	return region


func can_place_event_in(pos: Vector2i) -> bool:
	if current_object:
		var system = get_node_or_null("/root/RPGSYSTEM")
		if system:
			var map_id = current_object.internal_id
			var ids = [
				"player_start_position",
				"land_transport_start_position",
				"sea_transport_start_position",
				"air_transport_start_position",
			]
			for id in ids:
				var data: RPGMapPosition = system.database.system.get(id)
				if data and data.map_id == map_id and data.position == current_tile_pos:
					return false
		
		var extra_margin = 5
		var used_rect = current_object.get_used_rect()

		var real_position = current_object.map_to_local(pos)
		
		return used_rect.has_point(real_position)
	
	return false


func get_preview(scene: String, receiver: Object, function: StringName, userdata: Variant = null) -> void:
	scene_preview.queue_resource_preview(scene, receiver, function, userdata)


func _save_external_data() -> void:
	#var rpg_map_info = get_node_or_null("/root/RPGMapsInfo")
	#if rpg_map_info:
		#var opened_maps: Array = []
		#var interface = get_editor_interface()
		#var current_opened_scenes = interface.get_open_scenes()
		#var resource_filesystem = interface.get_resource_filesystem()
		#for path in current_opened_scenes:
			#opened_maps.append(path)
		#
		#rpg_map_info.fix_maps(opened_maps)
		
	var system = get_node_or_null("/root/RPGSYSTEM")
	if system:
		system.save()
